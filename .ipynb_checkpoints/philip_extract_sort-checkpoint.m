{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-1-0c7eb36bd358>, line 22)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-1-0c7eb36bd358>\"\u001b[0;36m, line \u001b[0;32m22\u001b[0m\n\u001b[0;31m    if isempty(unit_TableIdx)\u001b[0m\n\u001b[0m                             ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "function [success, mean_wf] = extractMeanWF(uniqueID, tablePath)\n",
    "%EXTRACTMEANWF Summary of this function goes here\n",
    "%   Detailed explanation goes here\n",
    "% -----------------------\tTEST SETTINGS   -----------------------\n",
    "% clear all\n",
    "% clc\n",
    "% tablePath = 'C:\\Users\\Bread\\Desktop\\combinedTable\\nestedTable2.mat';\n",
    "% uniqueID = 'Mittens_112916_MCR1_C3U1';%'Ham_101217_FIO11_C30U1';%'Ham_101017_FIO10_C19U2';\n",
    "% ----------------------- Positive thinking -----------------------\n",
    "success = true;\n",
    "extractNewAnalog = false;\n",
    "% ----------------------- Settings -----------------------\n",
    "preThresholdUs = 600;\n",
    "postThresholdUs = 1400;\n",
    "preThresholdS = preThresholdUs/1e6;\n",
    "postThresholdS = postThresholdUs/1e6;\n",
    "% -------------- Load table and locate our desired unit  --------------\n",
    "loadStruct = load(tablePath);\n",
    "existingTable = loadStruct.cellTable;\n",
    "unit_TableIdx = find(strcmpi(existingTable.UniqueID, uniqueID));\n",
    "cellStruct = table2struct(existingTable);\n",
    "if isempty(unit_TableIdx)\n",
    "    error('Desired unit not found in table!!');\n",
    "end\n",
    "% -------------- Load the spike times --------------\n",
    "try\n",
    "    spikeFilePath = cellStruct(unit_TableIdx).SpikePath;\n",
    "    load(spikeFilePath, 'spikes');\n",
    "catch spikeLoadErr\n",
    "    success = false;\n",
    "    warning(['XNT (add2Table_StimOn_Response): Could not load spike times or waveforms --> ', spikeLoadErr.message]);\n",
    "    return\n",
    "end\n",
    "% Extract the session and unit strings from the table\n",
    "unitStr = cellStruct(unit_TableIdx).Unit;\n",
    "sessionStr = cellStruct(unit_TableIdx).Session;\n",
    "dataPath = cellStruct(unit_TableIdx).DataPath;\n",
    "validSpikeLookups = find(~cellfun(@isempty,spikes));\n",
    "unitNames = cell(size(validSpikeLookups));\n",
    "% --------------- Loop through valid units to find our desired unit ---------------\n",
    "for i = 1:size(validSpikeLookups,1)\n",
    "    \n",
    "    u = validSpikeLookups(i);\n",
    "    \n",
    "    unitStruct = spikes{u};\n",
    "    \n",
    "    if isfield(unitStruct, 'trialLimits')\n",
    "        unitLimits = unitStruct.trialLimits;\n",
    "    else\n",
    "        unitLimits = [];\n",
    "    end\n",
    "    \n",
    "    unitName = unitStruct.name;\n",
    "    \n",
    "    unitNames{i} = unitName;\n",
    "    \n",
    "end\n",
    "desiredUnit_Idx = find(strcmp(unitNames, unitStr));\n",
    "desiredUnit_Struct =  spikes{validSpikeLookups(desiredUnit_Idx)};\n",
    "desiredUnit_Spikes = desiredUnit_Struct.ts;\n",
    "desiredUnit_SourceChan =  desiredUnit_Struct.infoValues{    find(strcmp(desiredUnit_Struct.infoNames, 'Channel Name')) };\n",
    "desiredUnit_SourceChan = strrep(desiredUnit_SourceChan, 'SPK_', '');\n",
    "desiredUnit_SourceChan = strrep(desiredUnit_SourceChan, 'CutFromSMRX', '');\n",
    "desiredUnit_numSpikes = size(desiredUnit_Spikes,1);\n",
    "if extractNewAnalog\n",
    "    \n",
    "    spikeChannel_Struct = PL2Ad(dataPath, desiredUnit_SourceChan);\n",
    "    spikeChannel_fs = spikeChannel_Struct.ADFreq;\n",
    "    spikeChannel_numSamples = spikeChannel_Struct.FragCounts;\n",
    "    spikeChannel_timeInterval = 1/spikeChannel_fs;\n",
    "    spikeChannel_maxS = spikeChannel_timeInterval*spikeChannel_numSamples;\n",
    "    spikeChannel_tv = [0:spikeChannel_timeInterval:(spikeChannel_maxS-spikeChannel_timeInterval)];\n",
    "    \n",
    "    extractedAnalog_numSamples = size([(-preThresholdS):spikeChannel_timeInterval:postThresholdS],2);\n",
    "    \n",
    "    extractedAnalog = nan(desiredUnit_numSpikes, extractedAnalog_numSamples);\n",
    "    \n",
    "    \n",
    "    for s = 1:desiredUnit_numSpikes\n",
    "        \n",
    "        thisSpike_thresholdS = desiredUnit_Spikes(s);\n",
    "        \n",
    "        thisSpike_earlierS = thisSpike_thresholdS-preThresholdS;\n",
    "        thisSpike_laterS = thisSpike_thresholdS+postThresholdS;\n",
    "        \n",
    "        if thisSpike_earlierS > 0 && thisSpike_laterS <= spikeChannel_maxS\n",
    "            \n",
    "            %This method is apparently slower\n",
    "            %         tic\n",
    "            %         [~, thisSpike_earlier_TV_idx] = min(abs(spikeChannel_tv-thisSpike_earlierS));\n",
    "            %\n",
    "            %         thisSpike_tvIdxs = [thisSpike_earlier_TV_idx : (thisSpike_earlier_TV_idx+(extractedAnalog_numSamples-1))];\n",
    "            %         toc\n",
    "            \n",
    "            \n",
    "            \n",
    "            thisSpike_tvIdxs = find(spikeChannel_tv>= thisSpike_earlierS & spikeChannel_tv <= thisSpike_laterS);\n",
    "            % Since sometimes we're getting off by one sample let's just take the N samples after the first one for a fixed length vector\n",
    "            thisSpike_tvIdxs = thisSpike_tvIdxs(1):(thisSpike_tvIdxs(1)+(extractedAnalog_numSamples-1));\n",
    "            \n",
    "            \n",
    "            \n",
    "            thisSpike_analog =  spikeChannel_Struct.Values(thisSpike_tvIdxs);\n",
    "            extractedAnalog(s,:) =thisSpike_analog;\n",
    "            \n",
    "        end\n",
    "        \n",
    "    end\n",
    "    \n",
    "    mean_wf = nanmean(extractedAnalog);\n",
    "elseif isfield(desiredUnit_Struct, 'wf')\n",
    "    \n",
    "    all_wfs = desiredUnit_Struct.wf;\n",
    "    mean_wf = mean(all_wfs);\n",
    "else\n",
    "    success = false;\n",
    "    mean_wf = [];\n",
    "end"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
